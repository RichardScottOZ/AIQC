{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "9f97666b-0c52-428d-ad3e-7763e4093e6f",
   "metadata": {},
   "source": [
    "# Feature Importance for Genetic Target Validation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2cf1508d-9a38-4e8f-bb52-c2d523878c17",
   "metadata": {},
   "source": [
    "*Classifying 5 tumor types based on their mRNA expression levels in 20,532 genes.*"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "160a553c-a6ba-4e42-b565-0c35b2fc4ea4",
   "metadata": {},
   "source": [
    "![geneBanner](../images/gene_banner.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a6f4d83e-64a3-4a78-87a7-3401e7aa1e15",
   "metadata": {},
   "source": [
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c32dca02-47bc-402b-9f01-17396f302cb1",
   "metadata": {},
   "source": [
    "This dataset is comprised of:\n",
    "\n",
    "* *Features* - the expression of 20,532 genes from 800 participants. \n",
    "* *Labels* - the type of tumor: BRCA, KIRC, LUAD or PRAD.\n",
    "\n",
    "> *Source:* The Cancer Genome Atlas (TCGA)\n",
    "> https://archive.ics.uci.edu/ml/datasets/gene+expression+cancer+RNA-Seq\n",
    ">\n",
    "> Unfortunately, the gene names were not published with the dataset. I contacted the submitting organization, but they were not able to provide an index."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "46fa1d76-3236-47e0-92b9-34616c3a8a47",
   "metadata": {},
   "source": [
    "Although the oncogene relationships already known (the tumors are named after gene complexes), the purpose of this experiment is to validate that neural networks can be used to rapidly reveal these patterns in the presence of highly dimensional data. This methodology could also be repurposed for delineating biomarkers of different stages/ subtypes within a single disease."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e9cebc53-c488-488d-805b-aa88ce10ba7c",
   "metadata": {},
   "source": [
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4125b691-3080-406a-9363-698f687953e0",
   "metadata": {},
   "source": [
    "# Preprocessing"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d3b8578a-3139-46fc-8c3d-bb6605ce3e3c",
   "metadata": {},
   "source": [
    "Prior to ingestion:\n",
    "\n",
    "* Balanced the dataset based on the 'Class' column, which essentially meant deleting 150 BRCA samples.\n",
    "\n",
    "* Filtered out low expression frequency (EF) genes, but that still left over 19.5K genes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "00b862e6-7a9a-40a9-b5bc-e4b856355f35",
   "metadata": {},
   "outputs": [],
   "source": [
    "import aiqc\n",
    "from sklearn.preprocessing import OneHotEncoder, StandardScaler"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "61b68af6-e77f-458f-876c-29899e6dc9fa",
   "metadata": {},
   "outputs": [],
   "source": [
    "splitset = aiqc.Pipeline.Tabular.make(\n",
    "    # --- Data source ---\n",
    "    df_or_path = \"/Users/layne/desktop/TCGA/TCGA_expression.parquet\"\n",
    "\n",
    "    # --- Label preprocessing ---\n",
    "    , label_column = 'Class'\n",
    "    , label_encoder = dict(sklearn_preprocess=OneHotEncoder())\n",
    "\n",
    "    # --- Feature preprocessing ---\n",
    "    , feature_cols_excluded = ['Class', 'sample_ID']\n",
    "    , feature_encoders = [\n",
    "        dict(sklearn_preprocess=StandardScaler(), dtypes='float64')\n",
    "    ]\n",
    "\n",
    "    # --- Stratification ---\n",
    "    , size_validation = 0.22\n",
    "    , size_test = 0.08\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fcfb2f27-07ff-4063-8caa-da9abe162d98",
   "metadata": {},
   "source": [
    "# Modeling"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 200,
   "id": "0454f37a-5e9b-4e61-aa3e-5aa62a2f7b7f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import keras\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Input, Dense, Dropout, BatchNormalization, Activation\n",
    "from keras.callbacks import History"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 201,
   "id": "878a9741-951a-45ea-96c9-5c96e0d3d0e1",
   "metadata": {},
   "outputs": [],
   "source": [
    "def fn_build(features_shape, label_shape, **hp):\n",
    "    model = Sequential()\n",
    "    model.add(Input(shape=features_shape))\n",
    "    \n",
    "    # First hidden layer.\n",
    "    model.add(Dense(hp['first_neurons'], kernel_initializer=hp['init']))\n",
    "    model.add(BatchNormalization())\n",
    "    model.add(Activation(hp['activation']))\n",
    "    model.add(Dropout(hp['drop_rate']))\n",
    "    \n",
    "    # Output layer\n",
    "    model.add(Dense(units=label_shape[0], activation='sigmoid', kernel_initializer='glorot_uniform'))\n",
    "    return model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 205,
   "id": "acf1892f-6d6f-481e-8672-4796d5c345fd",
   "metadata": {},
   "outputs": [],
   "source": [
    "def fn_train(model, loser, optimizer, samples_train, samples_evaluate, **hp):\n",
    "    model.compile(loss=loser, optimizer=optimizer)\n",
    "\n",
    "    model.fit(\n",
    "        samples_train['features'], samples_train['labels']\n",
    "        , validation_data = (samples_evaluate['features'], samples_evaluate['labels'])\n",
    "        , verbose = 0\n",
    "        , batch_size = hp['batch_size']\n",
    "        , epochs = hp['epochs']\n",
    "        , callbacks = [History()]\n",
    "    )\n",
    "    return model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 202,
   "id": "d0acd0b8-a063-4ff8-87c9-866dcb70a8a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow as tf\n",
    "def fn_optimize(**hp):\n",
    "    optimizer = tf.keras.optimizers.Adamax(hp['learning_rate'])\n",
    "    return optimizer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 203,
   "id": "0dc1d216-08fa-4797-97ae-366748d1987c",
   "metadata": {},
   "outputs": [],
   "source": [
    "hyperparameters = dict(\n",
    "    first_neurons   = [120],\n",
    "    activation      = ['relu'],\n",
    "    init            = ['he_uniform'],\n",
    "    epochs          = [10],\n",
    "    batch_size      = [8],\n",
    "    drop_rate       = [0.4],\n",
    "    learning_rate   = [0.01]\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 213,
   "id": "01916884-2d5c-493d-984f-e1e030492cf7",
   "metadata": {},
   "outputs": [],
   "source": [
    "queue = aiqc.Experiment.make(\n",
    "    # --- Analysis type ---\n",
    "    library             = \"keras\"\n",
    "    , analysis_type     = \"classification_multi\"\n",
    "\n",
    "    # --- Model functions ---\n",
    "    , fn_build          = fn_build\n",
    "    , fn_train          = fn_train\n",
    "    , fn_lose           = None #auto\n",
    "    , fn_optimize       = fn_optimize #auto\n",
    "    , fn_predict        = None #auto\n",
    "\n",
    "    # --- Training options ---\n",
    "    , repeat_count      = 2\n",
    "    , permutation_count = 5\n",
    "    , hyperparameters   = hyperparameters\n",
    "    , pick_percent      = None\n",
    "\n",
    "    # --- Data source ---\n",
    "    , splitset_id       = splitset.id\n",
    "    , foldset_id        = None\n",
    "    , hide_test         = False\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "48edbb29-2d42-401f-8c38-7f836f8f7d69",
   "metadata": {
    "tags": []
   },
   "source": [
    "Ironically, the neural network takes less than 30 seconds to train. Whereas the feature permutations take 3+ hours."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 214,
   "id": "f4a6049f-63d7-4397-90ec-cf243cbc5420",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "ðŸ”® Training Models ðŸ”®:  50%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Œ                 | 1/2 [3:10:21<3:10:21, 11421.46s/it]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Queue was gracefully interrupted.\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
   "source": [
    "queue.run_jobs()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bbc78038-5bc9-449b-8602-213d167e218b",
   "metadata": {
    "tags": []
   },
   "source": [
    "The patterns must be shockingly absolute. After our first try with a single hidden layer, we achieve a perfect score. This is surprisingly given the use of a validation and test split, and given the fact that there are 4 different categories."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 215,
   "id": "56321445-c185-48c8-9ecd-11f16ed9d169",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>hyperparamcombo_id</th>\n",
       "      <th>job_id</th>\n",
       "      <th>repeat_index</th>\n",
       "      <th>predictor_id</th>\n",
       "      <th>split</th>\n",
       "      <th>accuracy</th>\n",
       "      <th>f1</th>\n",
       "      <th>loss</th>\n",
       "      <th>precision</th>\n",
       "      <th>recall</th>\n",
       "      <th>roc_auc</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>240</td>\n",
       "      <td>240</td>\n",
       "      <td>0</td>\n",
       "      <td>671</td>\n",
       "      <td>train</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.103631</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>240</td>\n",
       "      <td>240</td>\n",
       "      <td>0</td>\n",
       "      <td>671</td>\n",
       "      <td>validation</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.127999</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>240</td>\n",
       "      <td>240</td>\n",
       "      <td>0</td>\n",
       "      <td>671</td>\n",
       "      <td>test</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.134419</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1.0</td>\n",
       "      <td>1.0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   hyperparamcombo_id  job_id  repeat_index  predictor_id       split  \\\n",
       "0                 240     240             0           671       train   \n",
       "1                 240     240             0           671  validation   \n",
       "2                 240     240             0           671        test   \n",
       "\n",
       "   accuracy   f1      loss  precision  recall  roc_auc  \n",
       "0       1.0  1.0  0.103631        1.0     1.0      1.0  \n",
       "1       1.0  1.0  0.127999        1.0     1.0      1.0  \n",
       "2       1.0  1.0  0.134419        1.0     1.0      1.0  "
      ]
     },
     "execution_count": 215,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "queue.metrics_to_pandas()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0f200882-c306-4def-a567-285fe7e27fa5",
   "metadata": {},
   "outputs": [],
   "source": [
    "id = 671\n",
    "predictor = aiqc.Predictor.get_by_id(id)\n",
    "prediction = predictor.predictions[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "87b65881-85dd-42a8-b6b9-4cb650fa88d4",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "prediction.plot_confusion_matrix()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fe87262f-e3ee-4753-b465-d3164384197c",
   "metadata": {
    "tags": []
   },
   "source": [
    "![geneConfusion](../images/gene_confusion.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3e0816af-9a0e-491e-851c-704561a3d1a7",
   "metadata": {},
   "source": [
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6417b0c2-67d0-44fa-a19b-f421f456e4f5",
   "metadata": {},
   "source": [
    "# Interpretation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f5ffd7c9-41e5-4394-be2b-c7c8e8f78d8f",
   "metadata": {},
   "source": [
    "The `Experiment.permutation_count` parameter determines how many times each feature is permuted and run back through the model. The median difference in loss is then compared to the baseline loss of the model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "02712ad1-b6a1-446a-ac6b-2dd3aeb91524",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "prediction.plot_feature_importance(top_n=30)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9fb45af4-0826-4664-8eb6-245064d89a0f",
   "metadata": {
    "tags": []
   },
   "source": [
    "![geneFeatures](../images/gene_features.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b01a9b44-95db-4520-bb74-b7fb2f1ca096",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "df = pd.read_parquet(\"/Users/layne/desktop/TCGA/TCGA_expression.parquet\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "70b3cef4-ddcf-4f14-96c7-940f1d70a286",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "import plotly.express as px\n",
    "px.box(df, x=\"Class\", y='gene_15589', height=50).show()\n",
    "px.box(df, x=\"Class\", y='gene_17801', height=50).show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "badafeab-89d1-43b8-8211-c1c5b62fb7ac",
   "metadata": {
    "tags": []
   },
   "source": [
    "![geneBRCA](../images/gene_brca.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "198e6479-8a80-4ae2-8415-42582a1b9dba",
   "metadata": {
    "tags": []
   },
   "source": [
    "![geneGroup](../images/gene_group.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "34a0e4bf-1f53-482f-a40c-8122531b9a97",
   "metadata": {},
   "source": [
    "Interpretting the top 30 features in box plots, we can observe that: \n",
    "\n",
    "* BRCA expression is independent from the others. It is significantly more expressed across our top 5 candidate genes. The signal/ patterns are stronger.\n",
    "\n",
    "* The PRAD, LUAD, and KIRC, tumors appear to be coexpressed. Perhaps those cancers share a pathway.\n",
    "\n",
    "* There is an accumulation of over-expression across many genes, not just 1 or 2.\n",
    "\n",
    "* If we had a 5th control group of benign samples, we could learned a lot more."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
